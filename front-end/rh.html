<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOROZU - Visualizar Reconhecimentos (RH)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/pdf-lib@^1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>

    <link rel="stylesheet" href="styles/rh.css">
    <style>
        /* Estilos para notifica√ß√µes */
        .new-message-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 12px;
            animation: slideInRight 0.5s ease;
            border-left: 5px solid #ffd166;
            max-width: 350px;
        }

        .new-message-notification.show {
            display: flex;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .new-message-notification i {
            font-size: 1.5rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .new-message-content {
            flex: 1;
        }

        .new-message-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1rem;
        }

        .new-message-sender {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .close-notification {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .close-notification:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Badge para novas mensagens */
        .new-messages-badge {
            background: #ff6b6b;
            color: white;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* Bot√£o para carregar novas mensagens */
        .load-new-messages-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            margin: 10px auto;
            animation: fadeInUp 0.5s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .load-new-messages-btn:hover {
            background: linear-gradient(135deg, #45a049, #3d8b40);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .load-new-messages-btn i {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Anima√ß√£o para novas mensagens */
        .message-card.new-message {
            animation: highlightPulse 2s ease;
            border-left: 5px solid #4CAF50 !important;
        }

        @keyframes highlightPulse {
            0% { 
                background-color: rgba(76, 175, 80, 0.1); 
                transform: scale(1);
            }
            50% { 
                background-color: rgba(76, 175, 80, 0.3); 
                transform: scale(1.02);
            }
            100% { 
                background-color: transparent; 
                transform: scale(1);
            }
        }
    </style>
</head>

<body>
    <!-- Bot√£o de Logout -->
    <button id="logoutBtn" class="logout-btn" style="display: none;">
        <i class="fas fa-sign-out-alt"></i> Sair
    </button>
    
    <!-- Notifica√ß√£o de nova mensagem -->
    <div id="newMessageNotification" class="new-message-notification">
        <i class="fas fa-bell"></i>
        <div class="new-message-content">
            <div class="new-message-title">Nova mensagem de reconhecimento!</div>
            <div class="new-message-sender" id="notificationSender"></div>
        </div>
        <button class="close-notification" id="closeNotification">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <div class="container">
        <header class="yorozu-header">
            <div class="company-logo">
                <!-- <div class="japanese-name">„Éñ„É©„Ç∏„É´„ÅÆ„É®„É≠„Ç∫Ëá™ÂãïËªä/div> -->
                <div class="english-name">YOROZU AUTOMOTIVA DO BRASIL</div>
                <div class="app-title">Visualiza√ß√£o de Reconhecimentos - RH</div>
            </div>
        </header>

        <div class="nav-container">
            <a href="mensagem.html" class="nav-btn">
                <i class="fas fa-envelope"></i> Enviar Reconhecimento
            </a>
            <a href="rh.html" class="nav-btn active">
                <i class="fas fa-eye"></i> Visualizar Mensagens (RH)
            </a>
        </div>

        <!-- P√°gina de visualiza√ß√£o do RH -->
        <div class="rh-container">
            <h1 class="page-title"><i class="fas fa-chart-bar"></i> Painel de Reconhecimentos - RH</h1>
            <p class="page-description">Visualize todas as mensagens de reconhecimento enviadas pelos colaboradores.
                Gere certificados em PDF para cada mensagem.</p>

            <!-- Estat√≠sticas -->
            <div class="stats" id="statsContainer">
                <!-- Preenchido via JavaScript -->
            </div>

            <!-- A√ß√µes em lote -->
            <div class="messages-header">
                <h3 style="color: #0d2b5c;"><i class="fas fa-list"></i> Mensagens de Reconhecimento</h3>
                <div style="display: flex; gap: 10px;">
                    <button id="deleteAllMessages" class="btn btn-danger">
                        <i class="fas fa-trash"></i> Excluir Todas
                    </button>
                </div>
            </div>

            <!-- Bot√£o para carregar novas mensagens (aparece dinamicamente) -->
            <div id="loadNewMessagesContainer" style="display: none; text-align: center; margin: 15px 0;"></div>

            <!-- Lista de mensagens -->
            <div class="messages-container" id="messagesContainer">
                <!-- Preenchido via JavaScript -->
            </div>
        </div>

        <!-- Modal de confirma√ß√£o para exclus√£o em lote -->
        <div id="confirmDeleteAllModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Confirmar
                    Exclus√£o</h2>
                <p id="confirmDeleteAllText" style="margin-bottom: 25px;"></p>
                <div class="modal-actions">
                    <button id="cancelDeleteAll" class="btn">Cancelar</button>
                    <button id="confirmDeleteAll" class="btn btn-danger">Excluir Todas</button>
                </div>
            </div>
        </div>

        <!-- Modal de confirma√ß√£o para exclus√£o individual -->
        <div id="confirmDeleteModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Confirmar
                    Exclus√£o</h2>
                <p id="confirmDeleteText" style="margin-bottom: 25px;"></p>
                <div class="modal-actions">
                    <button id="cancelDelete" class="btn">Cancelar</button>
                    <button id="confirmDelete" class="btn btn-danger">Excluir</button>
                </div>
            </div>
        </div>

        <!-- Loader -->
        <div id="pdfLoader" class="loader">
            <div class="loader-spinner"></div>
            <p>Gerando certificado em PDF...</p>
        </div>

        <footer>
            <p>YOROZU AUTOMOTIVA DO BRASIL - Sistema de Reconhecimento entre Colaboradores</p>
            <p class="yorozu-footer">Ê†™Âºè‰ºöÁ§æ ‰∏â„ÄáÂÖ≠ - ÂæìÊ•≠Âì°Ë©ï‰æ°„Ç∑„Çπ„ÉÜ„É†</p>
            <p>Prot√≥tipo para demonstra√ß√£o interna. Dados armazenados no banco de dados Neon.</p>
        </footer>
    </div>

    <script>
        // URL da API
        const API_URL = 'https://omedeto.onrender.com/api';

        // Vari√°veis para controle da exclus√£o individual
        let currentMessageIdToDelete = null;
        
        // Sistema de atualiza√ß√£o em tempo real
        let lastMessageId = 0;
        let pollingInterval = null;
        let newMessagesCount = 0;
        let isPollingActive = true;

        // -----------------------
        // Japanese size tuning
        // -----------------------
        // Adjust this scale to taste (0.7‚Äì0.9). Lower = smaller Japanese text.
        const JAPANESE_SCALE = 0.78;

        // Detect if text contains CJK (Japanese/Chinese/Kanji/Kana etc.)
        function containsJapanese(text) {
            if (!text) return false;
            return /[\u3000-\u30FF\u4E00-\u9FFF\uFF00-\uFFEF]/.test(text);
        }

        // Draw centered text, automatically scaling if it's Japanese
        async function drawCenteredText(page, text, baseY, baseSize, font, color = PDFLib.rgb(0, 0, 0)) {
            const isJP = containsJapanese(text);
            const size = isJP ? baseSize * JAPANESE_SCALE : baseSize;

            let textWidth;
            try {
                textWidth = font.widthOfTextAtSize(text, size);
            } catch (e) {
                // fallback approximation if width measurement fails
                textWidth = text.length * size * (isJP ? 0.5 : 0.5);
            }

            const x = (page.getWidth() / 2) - (textWidth / 2);
            page.drawText(text, {
                x,
                y: baseY,
                size,
                font,
                color
            });
        }

        // Draw left-aligned text, scaling Japanese if necessary
        async function drawLeftText(page, text, x, y, baseSize, font, color = PDFLib.rgb(0, 0, 0)) {
            const isJP = containsJapanese(text);
            const size = isJP ? baseSize * JAPANESE_SCALE : baseSize;

            page.drawText(text, {
                x,
                y,
                size,
                font,
                color
            });
        }

        // ========== FUN√á√ÉO PARA CARREGAR FONTES JAPONESAS ==========
        async function loadJapaneseFont(pdfDoc, isBold = false) {
            // ensure fontkit is registered (harmless if already registered)
            try {
                pdfDoc.registerFontkit(fontkit);
            } catch (e) {
                // ignore if already registered
            }

            const fontPath = isBold
                ? '/fonts/NotoSansJP-Bold.otf'
                : '/fonts/NotoSansJP-Regular.otf';

            const response = await fetch(fontPath);

            if (!response.ok) {
                throw new Error(`Fonte japonesa n√£o encontrada: ${fontPath}`);
            }

            const fontBytes = await response.arrayBuffer();

            return await pdfDoc.embedFont(fontBytes, {
                subset: false
            });
        }

        // ========== SISTEMA DE AUTENTICA√á√ÉO ==========
        // Fun√ß√£o para obter o token de autentica√ß√£o
        function getAuthToken() {
            return localStorage.getItem('rh_auth_token');
        }

        // Fun√ß√£o para fazer requisi√ß√µes autenticadas
        async function makeAuthenticatedRequest(endpoint, options = {}) {
            const token = getAuthToken();
            if (!token) {
                throw new Error('N√£o autenticado');
            }

            const defaultOptions = {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            };

            const mergedOptions = { ...defaultOptions, ...options };
            const response = await fetch(`${API_URL}${endpoint}`, mergedOptions);

            if (response.status === 401) {
                // Token inv√°lido ou expirado
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                window.location.href = 'login.html';
                throw new Error('Sess√£o expirada');
            }

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Erro na requisi√ß√£o');
            }

            return response.json();
        }

        // Verificar autentica√ß√£o
        function checkAuth() {
            const authToken = localStorage.getItem('rh_auth_token');
            const authExpires = localStorage.getItem('rh_auth_expires');

            console.log('üîç Verificando autentica√ß√£o...');
            console.log('Token encontrado:', authToken ? 'Sim' : 'N√£o');
            console.log('Expira√ß√£o:', authExpires ? new Date(parseInt(authExpires)).toLocaleString() : 'N√£o definida');

            if (!authToken) {
                console.log('‚ùå Nenhum token de autentica√ß√£o encontrado');
                return false;
            }

            // Verificar se o token expirou
            const now = Date.now();
            if (authExpires && now > parseInt(authExpires)) {
                console.log('‚ùå Token expirado em:', new Date(parseInt(authExpires)).toLocaleString());
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                return false;
            }

            // Verificar adicionalmente se o token √© v√°lido decodificando-o
            try {
                // Um token JWT tem 3 partes: header.payload.signature
                const parts = authToken.split('.');
                if (parts.length !== 3) {
                    console.log('‚ùå Token JWT inv√°lido (n√£o tem 3 partes)');
                    localStorage.removeItem('rh_auth_token');
                    localStorage.removeItem('rh_auth_expires');
                    return false;
                }

                // Tentar decodificar o payload (segunda parte)
                const payload = JSON.parse(atob(parts[1]));
                console.log('‚úÖ Token JWT v√°lido, payload:', payload);

                // Verificar expira√ß√£o no pr√≥prio token (opcional)
                if (payload.exp && payload.exp * 1000 < Date.now()) {
                    console.log('‚ùå Token JWT expirado (no payload)');
                    localStorage.removeItem('rh_auth_token');
                    localStorage.removeItem('rh_auth_expires');
                    return false;
                }

            } catch (error) {
                console.log('‚ùå Token JWT inv√°lido (erro ao decodificar):', error.message);
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                return false;
            }

            console.log('‚úÖ Usu√°rio autenticado com sucesso');
            return true;
        }

        // Fun√ß√£o para limpar tokens de autentica√ß√£o antigos
        function cleanupOldAuth() {
            // Limpar tokens antigos com nomes diferentes
            const oldTokenNames = ['token', 'authToken', 'jwtToken', 'userToken'];

            oldTokenNames.forEach(tokenName => {
                if (localStorage.getItem(tokenName)) {
                    console.log(`üóëÔ∏è  Limpando token antigo: ${tokenName}`);
                    localStorage.removeItem(tokenName);
                }
            });
        }
        // Primeiro, limpar tokens antigos
        cleanupOldAuth();

        // Redirecionar para login se n√£o autenticado
        if (!checkAuth()) {
            alert('Acesso negado. Por favor, fa√ßa login.');
            window.location.href = 'login.html';
        } else {
            // Mostrar bot√£o de logout
            document.getElementById('logoutBtn').style.display = 'flex';
        }

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', function () {
            if (confirm('Deseja realmente sair do sistema?')) {
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                window.location.href = 'login.html';
            }
        });

        // ========== FUN√á√ïES DO SISTEMA DE MENSAGENS (API) ==========
        async function getAllMessages() {
            try {
                const response = await makeAuthenticatedRequest('/messages');
                if (response.success && response.data) {
                    return response.data;
                }
                return [];
            } catch (error) {
                console.error('Erro ao buscar mensagens:', error);
                alert(`Erro ao buscar mensagens: ${error.message}`);
                return [];
            }
        }

        async function deleteMessage(id) {
            try {
                const response = await makeAuthenticatedRequest(`/messages/${id}`, {
                    method: 'DELETE'
                });
                if (response.success) {
                    alert(response.message || 'Mensagem exclu√≠da com sucesso');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao excluir mensagem:', error);
                alert(`Erro ao excluir mensagem: ${error.message}`);
                return false;
            }
        }

        async function deleteAllMessages() {
            try {
                const response = await makeAuthenticatedRequest('/messages', {
                    method: 'DELETE'
                });
                if (response.success) {
                    alert(response.message || 'Todas as mensagens foram exclu√≠das com sucesso');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao excluir mensagens:', error);
                alert(`Erro ao excluir mensagens: ${error.message}`);
                return false;
            }
        }

        async function getStats() {
            try {
                const response = await makeAuthenticatedRequest('/stats');
                if (response.success && response.data) {
                    return response.data;
                }
                return {
                    total: 0,
                    uniqueSenders: 0,
                    uniqueRecipients: 0
                };
            } catch (error) {
                console.error('Erro ao buscar estat√≠sticas:', error);
                return {
                    total: 0,
                    uniqueSenders: 0,
                    uniqueRecipients: 0,
                    printed: 0
                };
            }
        }

        async function displayStats() {
            const stats = await getStats();
            const statsContainer = document.getElementById('statsContainer');

            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">Total de Mensagens</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.printed}</div>
                    <div class="stat-label">Mensagens Impressas</div>
                </div>
            `;
        }

        // ========== FUN√á√ÉO PARA LIMPAR TEXTO PARA PDF ==========
        function cleanTextForPDF(text) {
            if (!text) return '';
            return text
                .replace(/\r?\n|\r/g, ' ')  // Substituir quebras de linha por espa√ßo
                .trim();
        }

        // ========== FUN√á√ÉO PARA FORMATAR MENSAGEM EM LINHAS ==========
        function formatMessageLines(message, maxCharsPerLine = 50, maxLines = 8) {
            if (!message) return [];

            // Primeiro, dividir pelas quebras de linha originais
            const originalLines = message.split('\n');
            const lines = [];
            
            for (const originalLine of originalLines) {
                if (originalLine.trim() === '') {
                    // Linha vazia (apenas quebra de linha)
                    lines.push('');
                    continue;
                }
                
                const words = originalLine.split(' ');
                let currentLine = '';

                for (const word of words) {
                    // Se adicionar esta palavra exceder o limite da linha
                    if ((currentLine + ' ' + word).length > maxCharsPerLine && currentLine.length > 0) {
                        // Se j√° atingiu o m√°ximo de linhas, para aqui
                        if (lines.length >= maxLines - 1) {
                            // Adiciona "..." no final da √∫ltima linha se truncou
                            if (currentLine.length > maxCharsPerLine - 3) {
                                currentLine = currentLine.substring(0, maxCharsPerLine - 3) + '...';
                            }
                            lines.push(currentLine);
                            return lines;
                        }
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = currentLine ? currentLine + ' ' + word : word;
                    }
                }

                // Adiciona a √∫ltima linha se houver conte√∫do
                if (currentLine) {
                    // Se j√° atingiu o m√°ximo de linhas, para aqui
                    if (lines.length >= maxLines) {
                        // Adiciona "..." no final se necess√°rio
                        if (currentLine.length > maxCharsPerLine - 3) {
                            currentLine = currentLine.substring(0, maxCharsPerLine - 3) + '...';
                        }
                        lines.push(currentLine);
                        return lines;
                    }
                    lines.push(currentLine);
                }
                
                // Se atingiu o m√°ximo de linhas, para
                if (lines.length >= maxLines) {
                    return lines;
                }
            }

            // Limita ao n√∫mero m√°ximo de linhas
            return lines.slice(0, maxLines);
        }

        // ========== FUN√á√ÉO CORRIGIDA PARA GERAR CERTIFICADO PDF ==========
        async function gerarCertificadoPDF(remetente, destinatario, mensagem) {
            const loader = document.getElementById('pdfLoader');
            try {
                loader.style.display = 'flex';

                console.log('Gerando certificado PDF...');
                console.log('Remetente:', remetente);
                console.log('Destinat√°rio:', destinatario);

                // Limpar os textos
                const cleanedRemetente = cleanTextForPDF(remetente);
                const cleanedDestinatario = cleanTextForPDF(destinatario);
                const cleanedMensagem = cleanTextForPDF(mensagem);

                // Validar comprimento m√°ximo
                if (cleanedMensagem.length > 400) {
                    alert('A mensagem √© muito longa para o certificado. Por favor, limite a 400 caracteres.');
                    loader.style.display = 'none';
                    return;
                }

                // Tentar carregar o template PDF
                let pdfBytes;
                try {
                    const response = await fetch('Certificado.pdf');
                    if (!response.ok) throw new Error('PDF n√£o encontrado');
                    pdfBytes = await response.arrayBuffer();
                } catch {
                    // Se n√£o encontrar, criar PDF alternativo
                    console.log('Template n√£o encontrado, criando PDF alternativo');
                    return criarPDFAlternativo(cleanedRemetente, cleanedDestinatario, cleanedMensagem);
                }

                // Carregar e modificar o PDF
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                pdfDoc.registerFontkit(fontkit);
                const pages = pdfDoc.getPages();
                const firstPage = pages[0];
                const { width, height } = firstPage.getSize();

                // Carregar fontes japonesas
                console.log('Carregando fontes japonesas...');
                const fontRegular = await loadJapaneseFont(pdfDoc, false);
                console.log('Fontes carregadas com sucesso');

                // Calcular posi√ß√µes
                const centerX = width / 2;

                // Adicionar remetente - agora using automatic JP scaling + centering helper
                const remetenteSize = 18;
                await drawCenteredText(firstPage, cleanedRemetente, 150, remetenteSize, fontRegular, PDFLib.rgb(0, 0, 0));

                // Adicionar mensagem formatada
                const messageLines = formatMessageLines(cleanedMensagem, 50, 10);
                let yPos = height - 200;

                console.log(`Mensagem dividida em ${messageLines.length} linhas`);

                for (let i = 0; i < messageLines.length; i++) {
                    const line = messageLines[i];
                    try {
                        await drawCenteredText(firstPage, line, yPos, 16, fontRegular, PDFLib.rgb(0, 0, 0));
                    } catch (error) {
                        console.warn(`Erro ao desenhar linha ${i}, usando posi√ß√£o padr√£o:`, error);
                        // Fallback left-aligned (also scaled for JP)
                        await drawLeftText(firstPage, line, 100, yPos, 16, fontRegular, PDFLib.rgb(0, 0, 0));
                    }
                    yPos -= 25;
                }

                // Salvar PDF
                console.log('Salvando PDF...');
                const modifiedPdfBytes = await pdfDoc.save();

                // Criar download
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                // Nome do arquivo sem caracteres especiais
                const fileName = `Certificado_YOROZU_${Date.now()}.pdf`;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log('Certificado gerado com sucesso!');

            } catch (error) {
                console.error('Erro ao gerar PDF:', error);
                alert('Erro ao gerar certificado: ' + error.message);
            } finally {
                loader.style.display = 'none';
            }
        }

        // ========== FUN√á√ÉO PARA CRIAR PDF ALTERNATIVO ==========
        async function criarPDFAlternativo(remetente, destinatario, mensagem) {
            console.log('Criando PDF alternativo...');

            const pdfDoc = await PDFLib.PDFDocument.create();
            pdfDoc.registerFontkit(fontkit);
            const page = pdfDoc.addPage([600, 400]);
            const { width, height } = page.getSize();

            // Carregar fontes japonesas
            const fontRegular = await loadJapaneseFont(pdfDoc, false);
            const fontBold = await loadJapaneseFont(pdfDoc, true);
            const color = PDFLib.rgb(0.05, 0.17, 0.36);

            // T√≠tulo (bold)
            await drawLeftText(page, 'CERTIFICADO DE RECONHECIMENTO', 50, height - 60, 24, fontBold, color);

            // Logo YOROZU
            await drawLeftText(page, 'YOROZU AUTOMOTIVA DO BRASIL', 50, height - 100, 18, fontBold, color);

            // Destinat√°rio (left, may be JP)
            const destinatarioText = `Para: ${destinatario}`;
            await drawLeftText(page, destinatarioText, 50, height - 160, 22, fontBold, PDFLib.rgb(0, 0, 0));

            // Mensagem formatada
            const messageLines = formatMessageLines(mensagem, 60, 6);
            let yPos = height - 180;
            for (let i = 0; i < messageLines.length; i++) {
                await drawLeftText(page, messageLines[i], 50, yPos, 14, fontRegular, PDFLib.rgb(0, 0, 0));
                yPos -= 25;
            }

            // Remetente
            const remetenteText = `De: ${remetente}`;
            await drawLeftText(page, remetenteText, 50, 100, 16, fontBold, PDFLib.rgb(0, 0, 0));

            // Data
            const data = new Date().toLocaleDateString('pt-BR');
            await drawLeftText(page, `Data: ${data}`, 50, 70, 14, fontRegular, PDFLib.rgb(0.4, 0.4, 0.4));

            // Salvar PDF
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            const fileName = `Certificado_YOROZU_${Date.now()}.pdf`;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log('PDF alternativo criado com sucesso!');
        }

        // ========== FUN√á√ïES PARA MARCA√á√ÉO DE IMPRESS√ÉO ==========
        async function markAsPrinted(messageId) {
            try {
                const response = await makeAuthenticatedRequest(`/messages/${messageId}/printed`, {
                    method: 'PUT'
                });

                if (response.success) {
                    // Encontrar o card da mensagem
                    const messageCard = document.querySelector(`.message-card[data-id="${messageId}"]`);

                    if (messageCard) {
                        // Adicionar classe de anima√ß√£o
                        messageCard.classList.add('slide-down');

                        // Aguardar anima√ß√£o e mover para baixo
                        setTimeout(async () => {
                            // Recarregar mensagens ordenadas
                            await displayMessagesOrdered();
                        }, 500);
                    }

                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao marcar como impresso:', error);
                alert(`Erro: ${error.message}`);
                return false;
            }
        }

        // Fun√ß√£o para buscar mensagens ordenadas (n√£o impressas primeiro)
        async function getAllMessagesOrdered() {
            try {
                const response = await makeAuthenticatedRequest('/messages/ordered');
                if (response.success && response.data) {
                    return response.data;
                }
                return [];
            } catch (error) {
                console.error('Erro ao buscar mensagens ordenadas:', error);
                // Fallback para a rota normal
                return getAllMessages();
            }
        }

        // ========== SISTEMA DE ATUALIZA√á√ÉO EM TEMPO REAL ==========
        
        // Fun√ß√£o para carregar o √∫ltimo ID de mensagem
        async function loadLastMessageId() {
            try {
                const messages = await getAllMessagesOrdered();
                if (messages.length > 0) {
                    // Ordenar por ID decrescente e pegar o maior
                    const sortedMessages = [...messages].sort((a, b) => b.id - a.id);
                    lastMessageId = sortedMessages[0].id;
                    console.log(`üìå √öltimo ID carregado: ${lastMessageId}`);
                }
            } catch (error) {
                console.error('Erro ao carregar √∫ltimo ID:', error);
            }
        }

        // Fun√ß√£o para verificar novas mensagens
        async function checkForNewMessages() {
            try {
                if (!isPollingActive) return;
                
                console.log('üîç Verificando novas mensagens...');
                
                const messages = await getAllMessagesOrdered();
                
                if (messages.length === 0) return;
                
                // Encontrar o maior ID
                const maxId = Math.max(...messages.map(msg => msg.id));
                
                if (maxId > lastMessageId) {
                    if (lastMessageId === 0) {
                        // Primeira vez, apenas definir o √∫ltimo ID
                        lastMessageId = maxId;
                    } else {
                        // Novas mensagens encontradas
                        const newMessages = messages.filter(msg => msg.id > lastMessageId);
                        lastMessageId = maxId;
                        
                        if (newMessages.length > 0) {
                            console.log(`üéâ ${newMessages.length} nova(s) mensagem(ns)!`);
                            
                            // Atualizar contador
                            newMessagesCount += newMessages.length;
                            
                            // Mostrar notifica√ß√£o para cada nova mensagem
                            newMessages.forEach((msg, index) => {
                                setTimeout(() => {
                                    showNewMessageNotification(msg);
                                }, index * 1000); // Espa√ßar as notifica√ß√µes
                            });
                            
                            // Atualizar interface
                            updateNewMessagesUI();
                        }
                    }
                }
            } catch (error) {
                console.error('Erro na verifica√ß√£o de novas mensagens:', error);
            }
        }

        // Fun√ß√£o para exibir notifica√ß√£o de nova mensagem
        function showNewMessageNotification(message) {
            const notification = document.getElementById('newMessageNotification');
            const senderElement = document.getElementById('notificationSender');
            
            // Configurar conte√∫do da notifica√ß√£o
            senderElement.textContent = `De: ${message.remetente_nome} para ${message.destinatario_nome}`;
            
            // Exibir notifica√ß√£o
            notification.classList.add('show');
            
            // Adicionar evento para fechar
            document.getElementById('closeNotification').onclick = () => {
                notification.classList.remove('show');
            };
            
            // Fechar automaticamente ap√≥s 8 segundos
            setTimeout(() => {
                notification.classList.remove('show');
            }, 8000);
        }

        // Fun√ß√£o para atualizar a interface com novas mensagens
        function updateNewMessagesUI() {
            // Atualizar t√≠tulo com badge
            const pageTitle = document.querySelector('.page-title');
            let badge = pageTitle.querySelector('.new-messages-badge');
            
            if (!badge) {
                badge = document.createElement('span');
                badge.className = 'new-messages-badge';
                pageTitle.appendChild(badge);
            }
            badge.textContent = newMessagesCount;
            
            // Adicionar bot√£o para carregar novas mensagens
            const loadContainer = document.getElementById('loadNewMessagesContainer');
            if (newMessagesCount > 0 && !loadContainer.querySelector('.load-new-messages-btn')) {
                const loadButton = document.createElement('button');
                loadButton.className = 'load-new-messages-btn';
                loadButton.innerHTML = `
                    <i class="fas fa-sync-alt"></i>
                   Atualizar Lista
                `;
                
                loadButton.onclick = async () => {
                    loadButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Carregando...';
                    loadButton.disabled = true;
                    
                    // Recarregar todas as mensagens
                    await displayStats();
                    await displayMessagesOrdered();
                    
                    // Resetar contador
                    newMessagesCount = 0;
                    updateNewMessagesUI();
                    
                    // Remover bot√£o ap√≥s 2 segundos
                    setTimeout(() => {
                        loadButton.remove();
                    }, 2000);
                };
                
                loadContainer.innerHTML = '';
                loadContainer.appendChild(loadButton);
                loadContainer.style.display = 'block';
            }
        }

        // Fun√ß√£o para iniciar o sistema de polling
        function startPolling() {
            console.log('üîÑ Iniciando sistema de atualiza√ß√£o em tempo real...');
            isPollingActive = true;
            
            // Verificar novas mensagens a cada 10 segundos
            pollingInterval = setInterval(async () => {
                await checkForNewMessages();
            }, 10000); // 10 segundos
            
            // Primeira verifica√ß√£o imediata
            setTimeout(async () => {
                await checkForNewMessages();
            }, 1000);
        }

        // Fun√ß√£o para parar o sistema de polling
        function stopPolling() {
            isPollingActive = false;
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                console.log('‚èπÔ∏è Sistema de atualiza√ß√£o parado');
            }
        }

        // ========== EXIBIR MENSAGENS ORDENADAS ==========
        async function displayMessagesOrdered() {
            const messages = await getAllMessagesOrdered();
            const container = document.getElementById('messagesContainer');

            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="no-messages">
                        <i class="fas fa-inbox"></i>
                        <h3>Nenhuma mensagem encontrada</h3>
                        <p>Aguardando novas mensagens de reconhecimento...</p>
                        <div style="margin-top: 20px;">
                            <i class="fas fa-sync-alt fa-spin" style="color: #0d2b5c;"></i>
                            <span style="color: #666; font-size: 0.9rem;">Monitorando novas mensagens</span>
                        </div>
                    </div>
                `;
                return;
            }

            // Separar mensagens impressas e n√£o impressas
            const pendingMessages = messages.filter(msg => !msg.isprinted);
            const printedMessages = messages.filter(msg => msg.isprinted);

            let html = '';

            // Mensagens n√£o impressas (pendentes)
            if (pendingMessages.length > 0) {
                pendingMessages.forEach((message, index) => {
                    html += generateMessageCardHTML(message, false);
                });
            }

            // Mensagens impressas
            if (printedMessages.length > 0) {
                html += `<h4 class="printed-section-title"><i class="fas fa-print"></i> J√° Impressas (${printedMessages.length})</h4>`;

                printedMessages.forEach((message, index) => {
                    html += generateMessageCardHTML(message, true);
                });
            }

            container.innerHTML = html;

            // Adicionar event listeners
            addMessageEventListeners();
        }

        // ========== GERAR HTML DO CARD DA MENSAGEM ==========
        function generateMessageCardHTML(message, isPrinted) {
            const dataFormatada = message.created_at ?
                new Date(message.created_at).toLocaleDateString('pt-BR') :
                new Date().toLocaleDateString('pt-BR');

            const horaFormatada = message.created_at ?
                new Date(message.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) :
                '';

            const mensagemPreview = message.mensagem.length > 200 ?
                message.mensagem.substring(0, 200) + '...' :
                message.mensagem;

            // Usar base64 para evitar problemas com caracteres especiais
            const remetenteBase64 = btoa(unescape(encodeURIComponent(message.remetente_nome)));
            const destinatarioBase64 = btoa(unescape(encodeURIComponent(message.destinatario_nome)));
            const mensagemBase64 = btoa(unescape(encodeURIComponent(message.mensagem)));

            // Data de impress√£o se dispon√≠vel
            const printedDate = message.printed_at ?
                new Date(message.printed_at).toLocaleDateString('pt-BR') :
                '';

            // Verificar se √© uma mensagem nova
            const isNew = message.id > lastMessageId;

            return `
                <div class="message-card ${isPrinted ? 'imprinted' : ''} ${isNew ? 'new-message' : ''}" data-id="${message.id}">
                    <div class="message-header">
                        <div class="message-info">
                            <div class="message-from-to">
                                <div class="message-from">
                                    <strong><i class="fas fa-user"></i> De:</strong> ${message.remetente_nome}
                                </div>
                                <div class="message-to">
                                    <strong><i class="fas fa-user-friends"></i> Para:</strong> ${message.destinatario_nome}
                                </div>
                            </div>
                            <div class="message-date">
                                <i class="far fa-clock"></i> ${dataFormatada} ${horaFormatada ? `√†s ${horaFormatada}` : ''}
                                ${isPrinted && printedDate ?
                    `<span class="imprinted-badge">‚úì Impresso em ${printedDate}</span>` :
                    `<span class="status-badge pending">PENDENTE</span>`
                }
                                ${isNew ? '<span class="status-badge new">NOVA</span>' : ''}
                            </div>
                        </div>
                        <div class="message-status">
                            ${!isPrinted ?
                    `<button class="btn-mark-printed mark-printed-btn" data-id="${message.id}">
                                    <i class="fas fa-check-circle"></i> Marcar como Impresso
                                </button>` :
                    ''
                }
                        </div>
                    </div>
                    <div class="message-content">
                        ${mensagemPreview}
                    </div>
                    <div class="message-actions">
                        <button class="btn btn-certificate generate-pdf-btn"
                                data-remetente="${remetenteBase64}"
                                data-destinatario="${destinatarioBase64}"
                                data-mensagem="${mensagemBase64}">
                            <i class="fas fa-file-pdf"></i> Gerar Certificado PDF
                        </button>
                        <button class="btn btn-delete delete-message-btn" data-id="${message.id}">
                            <i class="fas fa-trash"></i> Excluir
                        </button>
                    </div>
                </div>
            `;
        }

        // ========== ADICIONAR EVENT LISTENERS ==========
        function addMessageEventListeners() {
            // Bot√µes de gerar PDF
            document.querySelectorAll('.generate-pdf-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const remetente = decodeURIComponent(escape(atob(this.getAttribute('data-remetente'))));
                    const destinatario = decodeURIComponent(escape(atob(this.getAttribute('data-destinatario'))));
                    const mensagem = decodeURIComponent(escape(atob(this.getAttribute('data-mensagem'))));
                    gerarCertificadoPDF(remetente, destinatario, mensagem);
                });
            });

            // Bot√µes de marcar como impresso
            document.querySelectorAll('.mark-printed-btn').forEach(button => {
                button.addEventListener('click', async function () {
                    const messageId = this.getAttribute('data-id');
                    const confirmed = confirm('Marcar esta mensagem como impressa? Ela ser√° movida para a se√ß√£o "J√° Impressas".');

                    if (confirmed) {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';

                        await markAsPrinted(messageId);
                    }
                });
            });

            // Bot√µes de exclus√£o individual
            document.querySelectorAll('.delete-message-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const messageId = this.getAttribute('data-id');
                    const messageCard = this.closest('.message-card');
                    const destinatario = messageCard.querySelector('.message-to').textContent.replace('Para:', '').trim();

                    // Configurar o texto do modal
                    document.getElementById('confirmDeleteText').textContent =
                        `Tem certeza que deseja excluir a mensagem para ${destinatario}? Esta a√ß√£o n√£o pode ser desfeita.`;

                    // Armazenar o ID da mensagem a ser exclu√≠da
                    currentMessageIdToDelete = messageId;

                    // Exibir o modal
                    document.getElementById('confirmDeleteModal').style.display = 'flex';
                });
            });
        }

        // ========== CONFIGURAR MODAL DE EXCLUS√ÉO INDIVIDUAL ==========
        function setupIndividualDeleteModal() {
            const modal = document.getElementById('confirmDeleteModal');
            const cancelBtn = document.getElementById('cancelDelete');
            const confirmBtn = document.getElementById('confirmDelete');

            if (cancelBtn) {
                cancelBtn.addEventListener('click', function () {
                    modal.style.display = 'none';
                    currentMessageIdToDelete = null;
                });
            }

            if (confirmBtn) {
                confirmBtn.addEventListener('click', async function () {
                    if (currentMessageIdToDelete) {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Excluindo...';

                        const success = await deleteMessage(currentMessageIdToDelete);
                        if (success) {
                            modal.style.display = 'none';
                            await displayStats();
                            await displayMessagesOrdered();
                        }

                        this.disabled = false;
                        this.innerHTML = 'Excluir';
                        currentMessageIdToDelete = null;
                    }
                });
            }

            // Fechar modal ao clicar fora
            if (modal) {
                modal.addEventListener('click', function (e) {
                    if (e.target === this) {
                        this.style.display = 'none';
                        currentMessageIdToDelete = null;
                    }
                });
            }
        }

        // ========== INICIALIZA√á√ÉO ATUALIZADA ==========
        document.addEventListener('DOMContentLoaded', async function() {
            // Carregar dados
            await displayStats();
            await displayMessagesOrdered();
            await loadLastMessageId();
            
            // Iniciar sistema de atualiza√ß√£o
            startPolling();

            // Configurar bot√£o de excluir todas
            document.getElementById('deleteAllMessages').addEventListener('click', async function() {
                const messages = await getAllMessagesOrdered();
                const totalMessages = messages.length;

                if (totalMessages === 0) {
                    alert('N√£o h√° mensagens para excluir.');
                    return;
                }

                document.getElementById('confirmDeleteAllText').textContent =
                    `Tem certeza que deseja excluir todas as ${totalMessages} mensagens? Esta a√ß√£o n√£o pode ser desfeita.`;
                document.getElementById('confirmDeleteAllModal').style.display = 'flex';
            });

            // Configurar modal de exclus√£o em lote
            document.getElementById('cancelDeleteAll').addEventListener('click', function() {
                document.getElementById('confirmDeleteAllModal').style.display = 'none';
            });

            document.getElementById('confirmDeleteAll').addEventListener('click', async function() {
                const success = await deleteAllMessages();
                if (success) {
                    await displayStats();
                    await displayMessagesOrdered();
                }
                document.getElementById('confirmDeleteAllModal').style.display = 'none';
            });

            // Configurar modal de exclus√£o individual
            setupIndividualDeleteModal();

            // Fechar modais ao clicar fora
            document.getElementById('confirmDeleteAllModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.style.display = 'none';
                }
            });

            // Adicionar evento para parar polling quando a p√°gina n√£o estiver vis√≠vel
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    console.log('‚è∏Ô∏è P√°gina em segundo plano, pausando atualiza√ß√µes');
                    stopPolling();
                } else {
                    console.log('‚ñ∂Ô∏è P√°gina em primeiro plano, retomando atualiza√ß√µes');
                    startPolling();
                }
            });

            // Solicitar permiss√£o para notifica√ß√µes
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });
    </script>
</body>

</html>