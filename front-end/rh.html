<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOROZU - Visualizar Reconhecimentos (RH)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/pdf-lib@^1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js"></script>

    <link rel="stylesheet" href="styles/rh.css">
</head>

<body>
    <!-- Bot√£o de Logout -->
    <button id="logoutBtn" class="logout-btn" style="display: none;">
        <i class="fas fa-sign-out-alt"></i> Sair
    </button>

    <div class="container">
        <header class="yorozu-header">
            <div class="company-logo">
                <div class="japanese-name">Ê†™Âºè‰ºöÁ§æ ‰∏â„ÄáÂÖ≠</div>
                <div class="english-name">YOROZU CORPORATION</div>
                <div class="app-title">Visualiza√ß√£o de Reconhecimentos - RH</div>
            </div>
        </header>

        <div class="nav-container">
            <a href="mensagem.html" class="nav-btn">
                <i class="fas fa-envelope"></i> Enviar Reconhecimento
            </a>
            <a href="rh.html" class="nav-btn active">
                <i class="fas fa-eye"></i> Visualizar Mensagens (RH)
            </a>
        </div>

        <!-- P√°gina de visualiza√ß√£o do RH -->
        <div class="rh-container">
            <h1 class="page-title"><i class="fas fa-chart-bar"></i> Painel de Reconhecimentos - RH</h1>
            <p class="page-description">Visualize todas as mensagens de reconhecimento enviadas pelos colaboradores.
                Gere certificados em PDF para cada mensagem.</p>

            <!-- Estat√≠sticas -->
            <div class="stats" id="statsContainer">
                <!-- Preenchido via JavaScript -->
            </div>

            <!-- A√ß√µes em lote -->
            <div class="messages-header">
                <h3 style="color: #0d2b5c;"><i class="fas fa-list"></i> Mensagens de Reconhecimento</h3>
                <div style="display: flex; gap: 10px;">
                    <button id="deleteAllMessages" class="btn btn-danger">
                        <i class="fas fa-trash"></i> Excluir Todas
                    </button>
                </div>
            </div>

            <!-- Lista de mensagens -->
            <div class="messages-container" id="messagesContainer">
                <!-- Preenchido via JavaScript -->
            </div>
        </div>

        <!-- Modal de confirma√ß√£o para exclus√£o em lote -->
        <div id="confirmDeleteAllModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Confirmar
                    Exclus√£o</h2>
                <p id="confirmDeleteAllText" style="margin-bottom: 25px;"></p>
                <div class="modal-actions">
                    <button id="cancelDeleteAll" class="btn">Cancelar</button>
                    <button id="confirmDeleteAll" class="btn btn-danger">Excluir Todas</button>
                </div>
            </div>
        </div>

        <!-- Modal de confirma√ß√£o para exclus√£o individual -->
        <div id="confirmDeleteModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title"><i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i> Confirmar
                    Exclus√£o</h2>
                <p id="confirmDeleteText" style="margin-bottom: 25px;"></p>
                <div class="modal-actions">
                    <button id="cancelDelete" class="btn">Cancelar</button>
                    <button id="confirmDelete" class="btn btn-danger">Excluir</button>
                </div>
            </div>
        </div>

        <!-- Loader -->
        <div id="pdfLoader" class="loader">
            <div class="loader-spinner"></div>
            <p>Gerando certificado em PDF...</p>
        </div>

        <footer>
            <p>YOROZU CORPORATION - Sistema de Reconhecimento entre Colaboradores</p>
            <p class="yorozu-footer">Ê†™Âºè‰ºöÁ§æ ‰∏â„ÄáÂÖ≠ - ÂæìÊ•≠Âì°Ë©ï‰æ°„Ç∑„Çπ„ÉÜ„É†</p>
            <p>Prot√≥tipo para demonstra√ß√£o interna. Dados armazenados no banco de dados Neon.</p>
        </footer>
    </div>

    <script>
        // URL da API
        const API_URL = 'https://omedeto.onrender.com/api';

        // Vari√°veis para controle da exclus√£o individual
        let currentMessageIdToDelete = null;

        // ========== FUN√á√ÉO PARA CARREGAR FONTES JAPONESAS ==========
        async function loadJapaneseFont(pdfDoc, isBold = false) {
            // üîë REQUIRED for custom fonts
            pdfDoc.registerFontkit(fontkit);

            const fontPath = isBold
                ? '/fonts/NotoSansJP-Bold.otf'
                : '/fonts/NotoSansJP-Regular.otf';

            const response = await fetch(fontPath);

            if (!response.ok) {
                throw new Error(`Fonte japonesa n√£o encontrada: ${fontPath}`);
            }

            const fontBytes = await response.arrayBuffer();

            return await pdfDoc.embedFont(fontBytes, {
                subset: false
            });
        }   


        // ========== SISTEMA DE AUTENTICA√á√ÉO ==========
        // Fun√ß√£o para obter o token de autentica√ß√£o
        function getAuthToken() {
            return localStorage.getItem('rh_auth_token');
        }

        // Fun√ß√£o para fazer requisi√ß√µes autenticadas
        async function makeAuthenticatedRequest(endpoint, options = {}) {
            const token = getAuthToken();
            if (!token) {
                throw new Error('N√£o autenticado');
            }

            const defaultOptions = {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            };

            const mergedOptions = { ...defaultOptions, ...options };
            const response = await fetch(`${API_URL}${endpoint}`, mergedOptions);

            if (response.status === 401) {
                // Token inv√°lido ou expirado
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                window.location.href = 'login.html';
                throw new Error('Sess√£o expirada');
            }

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Erro na requisi√ß√£o');
            }

            return response.json();
        }

        // Verificar autentica√ß√£o
        function checkAuth() {
            const authToken = localStorage.getItem('rh_auth_token');
            const authExpires = localStorage.getItem('rh_auth_expires');

            console.log('üîç Verificando autentica√ß√£o...');
            console.log('Token encontrado:', authToken ? 'Sim' : 'N√£o');
            console.log('Expira√ß√£o:', authExpires ? new Date(parseInt(authExpires)).toLocaleString() : 'N√£o definida');

            if (!authToken) {
                console.log('‚ùå Nenhum token de autentica√ß√£o encontrado');
                return false;
            }

            // Verificar se o token expirou
            const now = Date.now();
            if (authExpires && now > parseInt(authExpires)) {
                console.log('‚ùå Token expirado em:', new Date(parseInt(authExpires)).toLocaleString());
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                return false;
            }

            // Verificar adicionalmente se o token √© v√°lido decodificando-o
            try {
                // Um token JWT tem 3 partes: header.payload.signature
                const parts = authToken.split('.');
                if (parts.length !== 3) {
                    console.log('‚ùå Token JWT inv√°lido (n√£o tem 3 partes)');
                    localStorage.removeItem('rh_auth_token');
                    localStorage.removeItem('rh_auth_expires');
                    return false;
                }

                // Tentar decodificar o payload (segunda parte)
                const payload = JSON.parse(atob(parts[1]));
                console.log('‚úÖ Token JWT v√°lido, payload:', payload);

                // Verificar expira√ß√£o no pr√≥prio token (opcional)
                if (payload.exp && payload.exp * 1000 < Date.now()) {
                    console.log('‚ùå Token JWT expirado (no payload)');
                    localStorage.removeItem('rh_auth_token');
                    localStorage.removeItem('rh_auth_expires');
                    return false;
                }

            } catch (error) {
                console.log('‚ùå Token JWT inv√°lido (erro ao decodificar):', error.message);
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                return false;
            }

            console.log('‚úÖ Usu√°rio autenticado com sucesso');
            return true;
        }

        // Fun√ß√£o para limpar tokens de autentica√ß√£o antigos
        function cleanupOldAuth() {
            // Limpar tokens antigos com nomes diferentes
            const oldTokenNames = ['token', 'authToken', 'jwtToken', 'userToken'];

            oldTokenNames.forEach(tokenName => {
                if (localStorage.getItem(tokenName)) {
                    console.log(`üóëÔ∏è  Limpando token antigo: ${tokenName}`);
                    localStorage.removeItem(tokenName);
                }
            });
        }
        // Primeiro, limpar tokens antigos
        cleanupOldAuth();

        // Redirecionar para login se n√£o autenticado
        if (!checkAuth()) {
            alert('Acesso negado. Por favor, fa√ßa login.');
            window.location.href = 'login.html';
        } else {
            // Mostrar bot√£o de logout
            document.getElementById('logoutBtn').style.display = 'flex';
        }

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', function () {
            if (confirm('Deseja realmente sair do sistema?')) {
                localStorage.removeItem('rh_auth_token');
                localStorage.removeItem('rh_auth_expires');
                window.location.href = 'login.html';
            }
        });

        // ========== FUN√á√ïES DO SISTEMA DE MENSAGENS (API) ==========
        async function getAllMessages() {
            try {
                const response = await makeAuthenticatedRequest('/messages');
                if (response.success && response.data) {
                    return response.data;
                }
                return [];
            } catch (error) {
                console.error('Erro ao buscar mensagens:', error);
                alert(`Erro ao buscar mensagens: ${error.message}`);
                return [];
            }
        }

        async function deleteMessage(id) {
            try {
                const response = await makeAuthenticatedRequest(`/messages/${id}`, {
                    method: 'DELETE'
                });
                if (response.success) {
                    alert(response.message || 'Mensagem exclu√≠da com sucesso');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao excluir mensagem:', error);
                alert(`Erro ao excluir mensagem: ${error.message}`);
                return false;
            }
        }

        async function deleteAllMessages() {
            try {
                const response = await makeAuthenticatedRequest('/messages', {
                    method: 'DELETE'
                });
                if (response.success) {
                    alert(response.message || 'Todas as mensagens foram exclu√≠das com sucesso');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao excluir mensagens:', error);
                alert(`Erro ao excluir mensagens: ${error.message}`);
                return false;
            }
        }

        async function getStats() {
            try {
                const response = await makeAuthenticatedRequest('/stats');
                if (response.success && response.data) {
                    return response.data;
                }
                return {
                    total: 0,
                    uniqueSenders: 0,
                    uniqueRecipients: 0
                };
            } catch (error) {
                console.error('Erro ao buscar estat√≠sticas:', error);
                return {
                    total: 0,
                    uniqueSenders: 0,
                    uniqueRecipients: 0,
                    printed: 0
                };
            }
        }

        async function displayStats() {
            const stats = await getStats();
            const statsContainer = document.getElementById('statsContainer');

            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">Total de Mensagens</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.printed}</div>
                    <div class="stat-label">Mensagens Impressas</div>
                </div>
            `;
        }

        // ========== FUN√á√ÉO PARA LIMPAR TEXTO PARA PDF ==========
        function cleanTextForPDF(text) {
            if (!text) return '';
            return text
                .replace(/\r?\n|\r/g, ' ')  // Substituir quebras de linha por espa√ßo
                .trim();
        }

        // ========== FUN√á√ÉO PARA FORMATAR MENSAGEM EM LINHAS ==========
        function formatMessageLines(message, maxCharsPerLine = 50, maxLines = 8) {
            if (!message) return [];

            const words = message.split(' ');
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                // Se adicionar esta palavra exceder o limite da linha
                if ((currentLine + ' ' + word).length > maxCharsPerLine) {
                    // Se j√° atingiu o m√°ximo de linhas, para aqui
                    if (lines.length >= maxLines - 1) {
                        // Adiciona "..." no final da √∫ltima linha se truncou
                        if (currentLine.length > maxCharsPerLine - 3) {
                            currentLine = currentLine.substring(0, maxCharsPerLine - 3) + '...';
                        }
                        lines.push(currentLine);
                        return lines;
                    }
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = currentLine ? currentLine + ' ' + word : word;
                }
            }

            // Adiciona a √∫ltima linha se houver conte√∫do
            if (currentLine) {
                lines.push(currentLine);
            }

            // Limita ao n√∫mero m√°ximo de linhas
            return lines.slice(0, maxLines);
        }

        // ========== FUN√á√ÉO CORRIGIDA PARA GERAR CERTIFICADO PDF ==========
        async function gerarCertificadoPDF(remetente, destinatario, mensagem) {
            const loader = document.getElementById('pdfLoader');
            try {
                loader.style.display = 'flex';

                console.log('Gerando certificado PDF...');
                console.log('Remetente:', remetente);
                console.log('Destinat√°rio:', destinatario);

                // Limpar os textos
                const cleanedRemetente = cleanTextForPDF(remetente);
                const cleanedDestinatario = cleanTextForPDF(destinatario);
                const cleanedMensagem = cleanTextForPDF(mensagem);

                // Validar comprimento m√°ximo
                if (cleanedMensagem.length > 400) {
                    alert('A mensagem √© muito longa para o certificado. Por favor, limite a 400 caracteres.');
                    loader.style.display = 'none';
                    return;
                }

                // Tentar carregar o template PDF
                let pdfBytes;
                try {
                    const response = await fetch('Certificado.pdf');
                    if (!response.ok) throw new Error('PDF n√£o encontrado');
                    pdfBytes = await response.arrayBuffer();
                } catch {
                    // Se n√£o encontrar, criar PDF alternativo
                    console.log('Template n√£o encontrado, criando PDF alternativo');
                    return criarPDFAlternativo(cleanedRemetente, cleanedDestinatario, cleanedMensagem);
                }

                // Carregar e modificar o PDF
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                pdfDoc.registerFontkit(fontkit);
                const pages = pdfDoc.getPages();
                const firstPage = pages[0];
                const { width, height } = firstPage.getSize();

                // Carregar fontes japonesas
                console.log('Carregando fontes japonesas...');
                const fontRegular = await loadJapaneseFont(pdfDoc, false);
                console.log('Fontes carregadas com sucesso');

                // Calcular posi√ß√µes
                const centerX = width / 2;

                // Adicionar remetente - VERIFICA√á√ÉO DE SUPORTE DE CARACTERES
                const remetenteSize = 18;

                // Verificar se a fonte suporta os caracteres
                try {
                    const remetenteWidth = fontRegular.widthOfTextAtSize(cleanedRemetente, remetenteSize);

                    // Ajuste baseado no comprimento do texto
                    let xAdjustment = 0;
                    if (cleanedRemetente.length > 25) {
                        xAdjustment = 20 + (cleanedRemetente.length - 25) * 0.9;
                    } else {
                        xAdjustment = -40 + (cleanedRemetente.length * 1.5);
                    }

                    console.log(`Posicionando remetente: x=${centerX - (remetenteWidth / 2) + xAdjustment}, y=150`);

                    firstPage.drawText(cleanedRemetente, {
                        x: centerX - (remetenteWidth / 2) + xAdjustment,
                        y: 150,
                        size: remetenteSize,
                        font: fontRegular,
                        color: PDFLib.rgb(0, 0, 0),
                    });
                } catch (error) {
                    console.warn('Erro ao desenhar remetente, usando posi√ß√£o padr√£o:', error);
                    // Posi√ß√£o padr√£o em caso de erro
                    firstPage.drawText(cleanedRemetente, {
                        x: 100,
                        y: 150,
                        size: remetenteSize,
                        font: fontRegular,
                        color: PDFLib.rgb(0, 0, 0),
                    });
                }

                // Adicionar mensagem formatada
                const messageLines = formatMessageLines(cleanedMensagem, 50, 10);
                let yPos = height - 200;

                console.log(`Mensagem dividida em ${messageLines.length} linhas`);

                for (let i = 0; i < messageLines.length; i++) {
                    const line = messageLines[i];
                    try {
                        const lineWidth = fontRegular.widthOfTextAtSize(line, 16);
                        firstPage.drawText(line, {
                            x: centerX - (lineWidth / 2),
                            y: yPos,
                            size: 16,
                            font: fontRegular,
                            color: PDFLib.rgb(0, 0, 0),
                        });
                    } catch (error) {
                        console.warn(`Erro ao desenhar linha ${i}, usando posi√ß√£o padr√£o:`, error);
                        // Linha centralizada manualmente
                        firstPage.drawText(line, {
                            x: 100,
                            y: yPos,
                            size: 16,
                            font: fontRegular,
                            color: PDFLib.rgb(0, 0, 0),
                        });
                    }
                    yPos -= 25;
                }

                // Salvar PDF
                console.log('Salvando PDF...');
                const modifiedPdfBytes = await pdfDoc.save();

                // Criar download
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                // Nome do arquivo sem caracteres especiais
                const fileName = `Certificado_YOROZU_${Date.now()}.pdf`;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log('Certificado gerado com sucesso!');

            } catch (error) {
                console.error('Erro ao gerar PDF:', error);
                alert('Erro ao gerar certificado: ' + error.message);
            } finally {
                loader.style.display = 'none';
            }
        }

        // ========== FUN√á√ÉO PARA CRIAR PDF ALTERNATIVO ==========
        async function criarPDFAlternativo(remetente, destinatario, mensagem) {
            console.log('Criando PDF alternativo...');

            const pdfDoc = await PDFLib.PDFDocument.create();
            pdfDoc.registerFontkit(fontkit);
            const page = pdfDoc.addPage([600, 400]);
            const { width, height } = page.getSize();

            // Carregar fontes japonesas
            const fontRegular = await loadJapaneseFont(pdfDoc, false);
            const fontBold = await loadJapaneseFont(pdfDoc, true);
            const color = PDFLib.rgb(0.05, 0.17, 0.36);

            // T√≠tulo
            page.drawText('CERTIFICADO DE RECONHECIMENTO', {
                x: 50,
                y: height - 60,
                size: 24,
                font: fontBold,
                color: color,
            });

            // Logo YOROZU
            page.drawText('YOROZU CORPORATION', {
                x: 50,
                y: height - 100,
                size: 18,
                font: fontBold,
                color: color,
            });

            // Destinat√°rio
            const destinatarioText = `Para: ${destinatario}`;
            page.drawText(destinatarioText, {
                x: 50,
                y: height - 160,
                size: 22,
                font: fontBold,
                color: PDFLib.rgb(0, 0, 0),
            });

            // Mensagem formatada
            const messageLines = formatMessageLines(mensagem, 60, 6);
            let yPos = height - 180;
            for (let i = 0; i < messageLines.length; i++) {
                page.drawText(messageLines[i], {
                    x: 50,
                    y: yPos,
                    size: 14,
                    font: fontRegular,
                    color: PDFLib.rgb(0, 0, 0),
                });
                yPos -= 25;
            }

            // Remetente
            const remetenteText = `De: ${remetente}`;
            page.drawText(remetenteText, {
                x: 50,
                y: 100,
                size: 16,
                font: fontBold,
                color: PDFLib.rgb(0, 0, 0),
            });

            // Data
            const data = new Date().toLocaleDateString('pt-BR');
            page.drawText(`Data: ${data}`, {
                x: 50,
                y: 70,
                size: 14,
                font: fontRegular,
                color: PDFLib.rgb(0.4, 0.4, 0.4),
            });

            // Salvar PDF
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            const fileName = `Certificado_YOROZU_${Date.now()}.pdf`;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log('PDF alternativo criado com sucesso!');
        }

        // ========== FUN√á√ïES PARA MARCA√á√ÉO DE IMPRESS√ÉO ==========
        async function markAsPrinted(messageId) {
            try {
                const response = await makeAuthenticatedRequest(`/messages/${messageId}/printed`, {
                    method: 'PUT'
                });

                if (response.success) {
                    // Encontrar o card da mensagem
                    const messageCard = document.querySelector(`.message-card[data-id="${messageId}"]`);

                    if (messageCard) {
                        // Adicionar classe de anima√ß√£o
                        messageCard.classList.add('slide-down');

                        // Aguardar anima√ß√£o e mover para baixo
                        setTimeout(async () => {
                            // Recarregar mensagens ordenadas
                            await displayMessagesOrdered();
                        }, 500);
                    }

                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erro ao marcar como impresso:', error);
                alert(`Erro: ${error.message}`);
                return false;
            }
        }

        // Fun√ß√£o para buscar mensagens ordenadas (n√£o impressas primeiro)
        async function getAllMessagesOrdered() {
            try {
                const response = await makeAuthenticatedRequest('/messages/ordered');
                if (response.success && response.data) {
                    return response.data;
                }
                return [];
            } catch (error) {
                console.error('Erro ao buscar mensagens ordenadas:', error);
                // Fallback para a rota normal
                return getAllMessages();
            }
        }

        // ========== EXIBIR MENSAGENS ORDENADAS ==========
        async function displayMessagesOrdered() {
            const messages = await getAllMessagesOrdered();
            const container = document.getElementById('messagesContainer');

            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="no-messages">
                        <i class="fas fa-inbox"></i>
                        <h3>Nenhuma mensagem encontrada</h3>
                        <p>Ainda n√£o h√° mensagens de reconhecimento no sistema.</p>
                    </div>
                `;
                return;
            }

            // Separar mensagens impressas e n√£o impressas
            const pendingMessages = messages.filter(msg => !msg.isprinted);
            const printedMessages = messages.filter(msg => msg.isprinted);

            let html = '';

            // Mensagens n√£o impressas (pendentes)
            if (pendingMessages.length > 0) {
                pendingMessages.forEach((message, index) => {
                    html += generateMessageCardHTML(message, false);
                });
            }

            // Mensagens impressas
            if (printedMessages.length > 0) {
                html += `<h4 class="printed-section-title"><i class="fas fa-print"></i> J√° Impressas (${printedMessages.length})</h4>`;

                printedMessages.forEach((message, index) => {
                    html += generateMessageCardHTML(message, true);
                });
            }

            container.innerHTML = html;

            // Adicionar event listeners
            addMessageEventListeners();
        }

        // ========== GERAR HTML DO CARD DA MENSAGEM ==========
        function generateMessageCardHTML(message, isPrinted) {
            const dataFormatada = message.created_at ?
                new Date(message.created_at).toLocaleDateString('pt-BR') :
                new Date().toLocaleDateString('pt-BR');

            const horaFormatada = message.created_at ?
                new Date(message.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) :
                '';

            const mensagemPreview = message.mensagem.length > 200 ?
                message.mensagem.substring(0, 200) + '...' :
                message.mensagem;

            // Usar base64 para evitar problemas com caracteres especiais
            const remetenteBase64 = btoa(unescape(encodeURIComponent(message.remetente_nome)));
            const destinatarioBase64 = btoa(unescape(encodeURIComponent(message.destinatario_nome)));
            const mensagemBase64 = btoa(unescape(encodeURIComponent(message.mensagem)));

            // Data de impress√£o se dispon√≠vel
            const printedDate = message.printed_at ?
                new Date(message.printed_at).toLocaleDateString('pt-BR') :
                '';

            return `
                <div class="message-card ${isPrinted ? 'imprinted' : ''}" data-id="${message.id}">
                    <div class="message-header">
                        <div class="message-info">
                            <div class="message-from-to">
                                <div class="message-from">
                                    <strong><i class="fas fa-user"></i> De:</strong> ${message.remetente_nome}
                                </div>
                                <div class="message-to">
                                    <strong><i class="fas fa-user-friends"></i> Para:</strong> ${message.destinatario_nome}
                                </div>
                            </div>
                            <div class="message-date">
                                <i class="far fa-clock"></i> ${dataFormatada} ${horaFormatada ? `√†s ${horaFormatada}` : ''}
                                ${isPrinted && printedDate ?
                    `<span class="imprinted-badge">‚úì Impresso em ${printedDate}</span>` :
                    `<span class="status-badge pending">PENDENTE</span>`
                }
                            </div>
                        </div>
                        <div class="message-status">
                            ${!isPrinted ?
                    `<button class="btn-mark-printed mark-printed-btn" data-id="${message.id}">
                                    <i class="fas fa-check-circle"></i> Marcar como Impresso
                                </button>` :
                    ''
                }
                        </div>
                    </div>
                    <div class="message-content">
                        ${mensagemPreview}
                    </div>
                    <div class="message-actions">
                        <button class="btn btn-certificate generate-pdf-btn"
                                data-remetente="${remetenteBase64}"
                                data-destinatario="${destinatarioBase64}"
                                data-mensagem="${mensagemBase64}">
                            <i class="fas fa-file-pdf"></i> Gerar Certificado PDF
                        </button>
                        <button class="btn btn-delete delete-message-btn" data-id="${message.id}">
                            <i class="fas fa-trash"></i> Excluir
                        </button>
                    </div>
                </div>
            `;
        }

        // ========== ADICIONAR EVENT LISTENERS ==========
        function addMessageEventListeners() {
            // Bot√µes de gerar PDF
            document.querySelectorAll('.generate-pdf-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const remetente = decodeURIComponent(escape(atob(this.getAttribute('data-remetente'))));
                    const destinatario = decodeURIComponent(escape(atob(this.getAttribute('data-destinatario'))));
                    const mensagem = decodeURIComponent(escape(atob(this.getAttribute('data-mensagem'))));
                    gerarCertificadoPDF(remetente, destinatario, mensagem);
                });
            });

            // Bot√µes de marcar como impresso
            document.querySelectorAll('.mark-printed-btn').forEach(button => {
                button.addEventListener('click', async function () {
                    const messageId = this.getAttribute('data-id');
                    const confirmed = confirm('Marcar esta mensagem como impressa? Ela ser√° movida para a se√ß√£o "J√° Impressas".');

                    if (confirmed) {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';

                        await markAsPrinted(messageId);
                    }
                });
            });

            // Bot√µes de exclus√£o individual
            document.querySelectorAll('.delete-message-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const messageId = this.getAttribute('data-id');
                    const messageCard = this.closest('.message-card');
                    const destinatario = messageCard.querySelector('.message-to').textContent.replace('Para:', '').trim();

                    // Configurar o texto do modal
                    document.getElementById('confirmDeleteText').textContent =
                        `Tem certeza que deseja excluir a mensagem para ${destinatario}? Esta a√ß√£o n√£o pode ser desfeita.`;

                    // Armazenar o ID da mensagem a ser exclu√≠da
                    currentMessageIdToDelete = messageId;

                    // Exibir o modal
                    document.getElementById('confirmDeleteModal').style.display = 'flex';
                });
            });
        }

        // ========== CONFIGURAR MODAL DE EXCLUS√ÉO INDIVIDUAL ==========
        function setupIndividualDeleteModal() {
            const modal = document.getElementById('confirmDeleteModal');
            const cancelBtn = document.getElementById('cancelDelete');
            const confirmBtn = document.getElementById('confirmDelete');

            if (cancelBtn) {
                cancelBtn.addEventListener('click', function () {
                    modal.style.display = 'none';
                    currentMessageIdToDelete = null;
                });
            }

            if (confirmBtn) {
                confirmBtn.addEventListener('click', async function () {
                    if (currentMessageIdToDelete) {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Excluindo...';

                        const success = await deleteMessage(currentMessageIdToDelete);
                        if (success) {
                            modal.style.display = 'none';
                            await displayStats();
                            await displayMessagesOrdered();
                        }

                        this.disabled = false;
                        this.innerHTML = 'Excluir';
                        currentMessageIdToDelete = null;
                    }
                });
            }

            // Fechar modal ao clicar fora
            if (modal) {
                modal.addEventListener('click', function (e) {
                    if (e.target === this) {
                        this.style.display = 'none';
                        currentMessageIdToDelete = null;
                    }
                });
            }
        }

        // ========== INICIALIZA√á√ÉO ATUALIZADA ==========
        document.addEventListener('DOMContentLoaded', function () {
            // Carregar dados
            displayStats();
            displayMessagesOrdered();

            // Configurar bot√£o de excluir todas
            document.getElementById('deleteAllMessages').addEventListener('click', async function () {
                const messages = await getAllMessagesOrdered();
                const totalMessages = messages.length;

                if (totalMessages === 0) {
                    alert('N√£o h√° mensagens para excluir.');
                    return;
                }

                document.getElementById('confirmDeleteAllText').textContent =
                    `Tem certeza que deseja excluir todas as ${totalMessages} mensagens? Esta a√ß√£o n√£o pode ser desfeita.`;
                document.getElementById('confirmDeleteAllModal').style.display = 'flex';
            });

            // Configurar modal de exclus√£o em lote
            document.getElementById('cancelDeleteAll').addEventListener('click', function () {
                document.getElementById('confirmDeleteAllModal').style.display = 'none';
            });

            document.getElementById('confirmDeleteAll').addEventListener('click', async function () {
                const success = await deleteAllMessages();
                if (success) {
                    await displayStats();
                    await displayMessagesOrdered();
                }
                document.getElementById('confirmDeleteAllModal').style.display = 'none';
            });

            // Configurar modal de exclus√£o individual
            setupIndividualDeleteModal();

            // Fechar modais ao clicar fora
            document.getElementById('confirmDeleteAllModal').addEventListener('click', function (e) {
                if (e.target === this) {
                    this.style.display = 'none';
                }
            });
        });
    </script>
</body>

</html>